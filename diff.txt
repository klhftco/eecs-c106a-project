--- move_group_python_interface_tutorial.py	2023-12-01 19:15:42.313447177 -0800
+++ ur5_actuator.py	2023-12-01 19:27:27.001161213 -0800
@@ -1,39 +1,5 @@
 #!/usr/bin/env python3
 
-# Software License Agreement (BSD License)
-#
-# Copyright (c) 2013, SRI International
-# All rights reserved.
-#
-# Redistribution and use in source and binary forms, with or without
-# modification, are permitted provided that the following conditions
-# are met:
-#
-#  * Redistributions of source code must retain the above copyright
-#    notice, this list of conditions and the following disclaimer.
-#  * Redistributions in binary form must reproduce the above
-#    copyright notice, this list of conditions and the following
-#    disclaimer in the documentation and/or other materials provided
-#    with the distribution.
-#  * Neither the name of SRI International nor the names of its
-#    contributors may be used to endorse or promote products derived
-#    from this software without specific prior written permission.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
-# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
-# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
-# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-# POSSIBILITY OF SUCH DAMAGE.
-#
-# Author: Acorn Pooley, Mike Lautman
-
 ## BEGIN_SUB_TUTORIAL imports
 ##
 ## To use the Python MoveIt interfaces, we will import the `moveit_commander`_ namespace.
@@ -42,7 +8,6 @@
 ##
 
 # Python 2/3 compatibility imports
-from __future__ import print_function
 from six.moves import input
 
 import sys
@@ -53,18 +18,18 @@
 import geometry_msgs.msg
 
 try:
-    from math import pi, tau, dist, fabs, cos
+    from math import pi, dist, fabs, cos
 except:  # For Python 2 compatibility
     from math import pi, fabs, cos, sqrt
 
-    tau = 2.0 * pi
-
     def dist(p, q):
         return sqrt(sum((p_i - q_i) ** 2.0 for p_i, q_i in zip(p, q)))
 
 
 from std_msgs.msg import String
 from moveit_commander.conversions import pose_to_list
+from robotiq_2f_gripper_control.msg import _Robotiq2FGripper_robot_output as robotiq_outputMsg
+from robotiq_2f_gripper_control.msg import _Robotiq2FGripper_robot_input as robotiq_inputMsg
 
 ## END_SUB_TUTORIAL
 
@@ -99,33 +64,31 @@
     return True
 
 
-class MoveGroupPythonInterfaceTutorial(object):
+class UR5_Manipulator(object):
     """MoveGroupPythonInterfaceTutorial"""
 
     def __init__(self):
-        super(MoveGroupPythonInterfaceTutorial, self).__init__()
+        super(UR5_Manipulator, self).__init__()
 
-        ## BEGIN_SUB_TUTORIAL setup
+        ## BEGIN setup
         ##
         ## First initialize `moveit_commander`_ and a `rospy`_ node:
         moveit_commander.roscpp_initialize(sys.argv)
-        rospy.init_node("move_group_python_interface_tutorial", anonymous=True)
+        rospy.init_node("ur5_manipulator", anonymous=True)
 
         ## Instantiate a `RobotCommander`_ object. Provides information such as the robot's
         ## kinematic model and the robot's current joint states
         robot = moveit_commander.RobotCommander()
 
+
         ## Instantiate a `PlanningSceneInterface`_ object.  This provides a remote interface
         ## for getting, setting, and updating the robot's internal understanding of the
         ## surrounding world:
         scene = moveit_commander.PlanningSceneInterface()
 
         ## Instantiate a `MoveGroupCommander`_ object.  This object is an interface
-        ## to a planning group (group of joints).  In this tutorial the group is the primary
-        ## arm joints in the Panda (UR5) robot, so we set the group's name to "manipulator".
-        ## If you are using a different robot, change this value to the name of your robot
-        ## arm planning group.
-        ## This interface can be used to plan and execute motions:
+        ## to a planning group (group of joints). The group name of the UR5 
+        ## arm is set to "manipulator".
         group_name = "manipulator"
         move_group = moveit_commander.MoveGroupCommander(group_name)
 
@@ -172,76 +135,61 @@
         self.eef_link = eef_link
         self.group_names = group_names
 
-    def go_to_joint_state(self):
-        # Copy class variables to local variables to make the web tutorials more clear.
-        # In practice, you should use the class variables directly unless you have a good
-        # reason not to.
-        move_group = self.move_group
+        ###### Gripper init ######
+        self.robotiq_gripper_pub = rospy.Publisher(
+            "Robotiq2FGripperRobotOutput", robotiq_outputMsg.Robotiq2FGripper_robot_output, queue_size=10)
+        self.robotiq_gripper_sub = rospy.Subscriber(
+            "Robotiq2FGripperRobotInput", robotiq_inputMsg.Robotiq2FGripper_robot_input, self.gripper_status_callback)
+
+
+    def go_to_joint_state(self, joint_goal):
 
         ## BEGIN_SUB_TUTORIAL plan_to_joint_state
         ##
         ## Planning to a Joint Goal
         ## ^^^^^^^^^^^^^^^^^^^^^^^^
-        ## The Panda's zero configuration is at a `singularity <https://www.quora.com/Robotics-What-is-meant-by-kinematic-singularity>`_, so the first
-        ## thing we want to do is move it to a slightly better configuration.
-        ## We use the constant `tau = 2*pi <https://en.wikipedia.org/wiki/Turn_(angle)#Tau_proposals>`_ for convenience:
         # We get the joint values from the group and change some of the values:
-        joint_goal = move_group.get_current_joint_values()
-        joint_goal[0] = 0
-        joint_goal[1] = -tau / 8
-        joint_goal[2] = 0
-        joint_goal[3] = -tau / 4
-        joint_goal[4] = 0
-        joint_goal[5] = tau / 6  # 1/6 of a turn
-        # joint_goal[6] = 0
+        # joint_goal = self.move_group.get_current_joint_values()
+        # joint_goal[0] = 0
+        # joint_goal[1] = -2*pi / 8
+        # joint_goal[2] = 0
+        # joint_goal[3] = -2*pi / 4
+        # joint_goal[4] = 0
+        # joint_goal[5] = 2*pi / 6  # 1/6 of a turn
 
         # The go command can be called with joint values, poses, or without any
         # parameters if you have already set the pose or joint target for the group
-        move_group.go(joint_goal, wait=True)
+        self.move_group.go(joint_goal, wait=True)
 
         # Calling ``stop()`` ensures that there is no residual movement
-        move_group.stop()
+        self.move_group.stop()
 
         ## END_SUB_TUTORIAL
 
         # For testing:
-        current_joints = move_group.get_current_joint_values()
+        current_joints = self.move_group.get_current_joint_values()
         return all_close(joint_goal, current_joints, 0.01)
 
-    def go_to_pose_goal(self):
-        # Copy class variables to local variables to make the web tutorials more clear.
-        # In practice, you should use the class variables directly unless you have a good
-        # reason not to.
-        move_group = self.move_group
-
-        ## BEGIN_SUB_TUTORIAL plan_to_pose
-        ##
-        ## Planning to a Pose Goal
-        ## ^^^^^^^^^^^^^^^^^^^^^^^
-        ## We can plan a motion for this group to a desired pose for the
-        ## end-effector:
-        pose_goal = geometry_msgs.msg.Pose()
-        pose_goal.orientation.x = 1.0
-        pose_goal.position.x = 0.4
-        pose_goal.position.y = 0.1
-        pose_goal.position.z = 0.4
+    def go_to_pose_goal(self, pose_goal):        
+        """moves ur5 to target pose"""
+        
+        # pose_goal = geometry_msgs.msg.Pose()
+        # pose_goal.orientation.x = 1.0
+        # pose_goal.position.x = 0.4
+        # pose_goal.position.y = 0.1
+        # pose_goal.position.z = 0.4
 
-        move_group.set_pose_target(pose_goal)
+        self.move_group.set_pose_target(pose_goal)
 
         ## Now, we call the planner to compute the plan and execute it.
         # `go()` returns a boolean indicating whether the planning and execution was successful.
-        success = move_group.go(wait=True)
+        success = self.move_group.go(wait=True)
         # Calling `stop()` ensures that there is no residual movement
-        move_group.stop()
+        self.move_group.stop()
         # It is always good to clear your targets after planning with poses.
         # Note: there is no equivalent function for clear_joint_value_targets().
-        move_group.clear_pose_targets()
+        self.move_group.clear_pose_targets()
 
-        ## END_SUB_TUTORIAL
-
-        # For testing:
-        # Note that since this section of code will not be included in the tutorials
-        # we use the class variable rather than the copied state variable
         current_pose = self.move_group.get_current_pose().pose
         return all_close(pose_goal, current_pose, 0.01)
 
@@ -332,7 +280,7 @@
 
     def wait_for_state_update(
         self, box_is_known=False, box_is_attached=False, timeout=4
-        ):
+    ):
         # Copy class variables to local variables to make the web tutorials more clear.
         # In practice, you should use the class variables directly unless you have a good
         # reason not to.
@@ -388,12 +336,14 @@
         ## Adding Objects to the Planning Scene
         ## ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
         ## First, we will create a box in the planning scene between the fingers:
+        width = 0.05
         box_pose = geometry_msgs.msg.PoseStamped()
         box_pose.header.frame_id = "base_link"
+        box_pose.pose.position.z = -width/2
         box_pose.pose.orientation.w = 1.0
         # box_pose.pose.position.z = 0.11  # above the panda_hand frame
         box_name = "box"
-        scene.add_box(box_name, box_pose, size=(1, 1, 1))
+        scene.add_box(box_name, box_pose, size=(2, 3, width))
 
         ## END_SUB_TUTORIAL
         # Copy local variables back to class variables. In practice, you should use the class
@@ -474,8 +424,34 @@
             box_is_attached=False, box_is_known=False, timeout=timeout
         )
 
+    def send_gripper_commad(self, rPR, rACT=1, rGTO=1, rATR=0, rSP=128, rFR=64):
+        gripper_command = robotiq_outputMsg.Robotiq2FGripper_robot_output()
+        gripper_command.rACT = rACT # must remain at 1, will activate upon being switched to one
+        gripper_command.rGTO = rGTO # 1 means it is following the go to routine
+        gripper_command.rATR = rATR # set to 1 for automatic release routine
+        gripper_command.rPR = rPR
+        gripper_command.rSP = rSP # 1/2 max speed
+        gripper_command.rFR = rFR # 1/4 max force
+        self.robotiq_gripper_pub.publish(gripper_command)
+
+    def gripper_status_callback(self, robotiq_inputMsg):
+        self.gripper_status = robotiq_inputMsg
+    def activate_gripper(self):
+        #if gripper.status.rACT == 1: give warining to activate
+        self.send_gripper_commad(rPR=0, rACT=1, rGTO=1)
+
+    def open_gripper(self):
+        #if gripper.status.rACT == 0: give warining to activate
+        self.send_gripper_commad(rPR=0)
+        #TODO wait till gripper stops
+    
+    def close_gripper(self):
+        #if gripper.status.rACT == 0: give warining to activate
+        self.send_gripper_commad(rPR=255)
+        #TODO wait till gripper stops
+
 
-def main():
+def test():
     try:
         print("")
         print("----------------------------------------------------------")
@@ -486,7 +462,7 @@
         input(
             "============ Press `Enter` to begin the tutorial by setting up the moveit_commander ..."
         )
-        tutorial = MoveGroupPythonInterfaceTutorial()
+        tutorial = UR5_Manipulator()
 
         input(
             "============ Press `Enter` to execute a movement using a joint state goal ..."
@@ -533,42 +509,107 @@
     except KeyboardInterrupt:
         return
 
+def executor():
+    ur5 = UR5_Manipulator()
+    ur5.add_box()
+
+
+
+    # ur5.robot.set_
+    ur5.activate_gripper()
+    
+    input(
+            "============ Press `Enter` to move to joint goal"
+        )
+    ur5.open_gripper()
+    joint_goal = ur5.move_group.get_current_joint_values()
+    joint_goal[0] = -1.61 # shoulder pan
+
+    joint_goal[1] = -2.16 # sholder lift
+    joint_goal[2] = -1.08 #  elbow
+    joint_goal[3] = 4.84 
+    joint_goal[4] = 1.60
+    joint_goal[5] = 2.85
+    ur5.go_to_joint_state(joint_goal)
+    
+    input(
+            "============ Press `Enter` to grab"
+        )
+    ur5.close_gripper()
+
+    
+
+    input(
+            "============ Press `Enter` to move to joint goal"
+        )
+    
+    joint_goal = ur5.move_group.get_current_joint_values()
+    joint_goal[0] = -1.13 # shoulder pan
+
+    joint_goal[1] = -1.96 # sholder lift
+    joint_goal[2] = -1.08 #  elbow
+    joint_goal[3] = 4.84 
+    joint_goal[4] = 1.60
+    joint_goal[5] = 2.85
+    ur5.go_to_joint_state(joint_goal)
+
+
+
+    input(
+            "============ Press `Enter` to move to joint goal"
+        )
+    
+    joint_goal = ur5.move_group.get_current_joint_values()
+    joint_goal[0] = -1.61 # shoulder pan
+
+    joint_goal[1] = -2.16 # sholder lift
+    joint_goal[2] = -1.08 #  elbow
+    joint_goal[3] = 4.84 
+    joint_goal[4] = 1.60
+    joint_goal[5] = 2.85
+    ur5.go_to_joint_state(joint_goal)
+
+    input(
+            "============ Press `Enter` to let go"
+        )
+    ur5.open_gripper()
+
+    # input(
+    #         "============ Press `Enter` to move to joint goal"
+    #     )
+    
+    # joint_goal = ur5.move_group.get_current_joint_values()
+    # joint_goal[0] = -1.08 
+
+    # joint_goal[1] = -2.16
+    # joint_goal[2] = -1.61
+    # joint_goal[3] = -4.84
+    # joint_goal[4] = 1.60
+    # joint_goal[5] = 2.85
+    # ur5.go_to_joint_state(joint_goal)
+    return
+    #intialize robot
+
+    #get camera to world frame locations
+    #get list of block locations
+    #get list of goal locations
+    #choose random block and goal
+    
+    block_pose = geometry_msgs.msg.Pose()
+    #move block to goal
+        #make frame that is centered on manipulator grab zone
+        #transform from 
+    ur5 = UR5_Manipulator()
+    ur5.go_to_pose_goal(block_pose)
+        #close gripper
+    gripper_command = robotiq_outputMsg.Robotiq2FGripper_robot_output()
+    gripper_command.rACT = 1
+    gripper_command.rGTO = 1
+    gripper_command.rSP = 128 # 1/2 max speed
+    gripper_command.rFR = 64 # 1/4 max force
+
+    #repeat until all blocks in goal
 
 if __name__ == "__main__":
-    main()
 
-## BEGIN_TUTORIAL
-## .. _moveit_commander:
-##    http://docs.ros.org/noetic/api/moveit_commander/html/namespacemoveit__commander.html
-##
-## .. _MoveGroupCommander:
-##    http://docs.ros.org/noetic/api/moveit_commander/html/classmoveit__commander_1_1move__group_1_1MoveGroupCommander.html
-##
-## .. _RobotCommander:
-##    http://docs.ros.org/noetic/api/moveit_commander/html/classmoveit__commander_1_1robot_1_1RobotCommander.html
-##
-## .. _PlanningSceneInterface:
-##    http://docs.ros.org/noetic/api/moveit_commander/html/classmoveit__commander_1_1planning__scene__interface_1_1PlanningSceneInterface.html
-##
-## .. _DisplayTrajectory:
-##    http://docs.ros.org/noetic/api/moveit_msgs/html/msg/DisplayTrajectory.html
-##
-## .. _RobotTrajectory:
-##    http://docs.ros.org/noetic/api/moveit_msgs/html/msg/RobotTrajectory.html
-##
-## .. _rospy:
-##    http://docs.ros.org/noetic/api/rospy/html/
-## CALL_SUB_TUTORIAL imports
-## CALL_SUB_TUTORIAL setup
-## CALL_SUB_TUTORIAL basic_info
-## CALL_SUB_TUTORIAL plan_to_joint_state
-## CALL_SUB_TUTORIAL plan_to_pose
-## CALL_SUB_TUTORIAL plan_cartesian_path
-## CALL_SUB_TUTORIAL display_trajectory
-## CALL_SUB_TUTORIAL execute_plan
-## CALL_SUB_TUTORIAL add_box
-## CALL_SUB_TUTORIAL wait_for_scene_update
-## CALL_SUB_TUTORIAL attach_object
-## CALL_SUB_TUTORIAL detach_object
-## CALL_SUB_TUTORIAL remove_object
-## END_TUTORIAL
+    executor()
